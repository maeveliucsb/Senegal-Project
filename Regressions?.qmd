---
title: "Playing with the Population Data"
date: 11/19/2025
format: html
editor: visual
---
#libraries
```{r}
library(terra)
library(rnaturalearth)
library(dplyr)
library(viridisLite)
library(fixest)
library(tidyverse) 
library(sf) 
library(here) 
library(stars) 
library(tmap) 
library(viridis) 
library(readr)
library(dplyr)
library(rnaturalearth)
library(rnaturalearthdata)
library(lubridate)
library(terra)
library(exactextractr)
library(readr)
library(haven)
library(sf)
library(units)
```

#reading it in
```{r}
ab <- read_sav("R9Geo.sav")
glbl <- rast("Popdata/Global.tif")
acled <- sf::st_read(here::here("ACLED.csv")) #its giving a warning that it's not spatial, thats ok i know
names(acled)[grep("lat|lon|long", names(acled), ignore.case = TRUE)]

lat_col <- "latitude"
lon_col <- "longitude"
acled <- acled %>%
  mutate(
    !!lat_col := as.numeric(.data[[lat_col]]),
    !!lon_col := as.numeric(.data[[lon_col]])
  ) %>%
  filter(!is.na(.data[[lat_col]]), !is.na(.data[[lon_col]]),
         between(.data[[lat_col]], -90, 90),
         between(.data[[lon_col]], -180, 180))
acled_sf <- st_as_sf(acled, coords = c(lon_col, lat_col), crs = 4326, remove = FALSE)
```
#Cropping to WA
```{r}
africa <- ne_countries(continent = "Africa", scale = "medium", returnclass = "sf")
# 3. Filter for your West African countries
wa_countries <- africa %>%
  dplyr::filter(admin %in% c(
    "Benin", "Burkina Faso", "Cabo Verde", "Ivory Coast",
    "Gambia", "Ghana", "Guinea", "Guinea Bissau", "Liberia", "Mali", "Mauritania", "Niger",
    "Nigeria", "Senegal", "Sierra Leone", "Togo"
  ))
wa_v <- vect(wa_countries)

# 5. Crop and mask the raster
glbl_wa <- crop(glbl, wa_v)
glbl_wa <- mask(glbl_wa, wa_v)

# 6. Plot result
plot(glbl_wa)
```

#configuring for regressions
```{r}
guess_coord <- function(df){
  nms <- names(df)
  lon_guess <- nms[grep("EA_GPS_LA", nms, ignore.case = TRUE)][1]
  lat_guess <- nms[grep("EA_GPS_LO", nms, ignore.case = TRUE)][1]
  stopifnot(!is.na(lon_guess), !is.na(lat_guess))
  list(lon = lon_guess, lat = lat_guess)
}
xy <- guess_coord(ab)
names(ab)

ab_sf <- ab %>%
  mutate(
    !!xy$lon := as.numeric(.data[[xy$lon]]),
    !!xy$lat := as.numeric(.data[[xy$lat]])
  ) %>%
  filter(
    between(.data[[xy$lat]], -90, 90),
    between(.data[[xy$lon]], -180, 180)
  ) %>%
  st_as_sf(coords = c(xy$lon, xy$lat), crs = 4326, remove = FALSE)
```
population density
```{r}
# --------------------------------------
# 3) Population density at respondent
#     (convert counts -> per km²)
# --------------------------------------
# If Global.tif is population *counts per cell*, convert to density:
cell_km2 <- terra::cellSize(glbl, unit = "km")
pop_dens <- glbl / cell_km2   # persons per km²

# Extract density for each AB point
# terra::extract() works with sf; returns a data.frame with ID + values
ab_sf$pop_density <- terra::extract(pop_dens, ab_sf)[, 2]

# Optional: cap huge outliers & log-scale for stability
ab_sf <- ab_sf %>%
  mutate(pop_density_log = log1p(pmin(pop_density, quantile(pop_density, 0.99, na.rm = TRUE))))

dist_25km <- set_units(25, km)

within_25km <- st_is_within_distance(
  ab_sf,
  acled_sf,
  dist = dist_25km
)

within_25km <- st_is_within_distance(ab_sf, acled_sf, dist = set_units(25, "km"))
conflict_counts <- lengths(within_25km)

ab_sf <- ab_sf %>%
  mutate(
    conflict_count     = conflict_counts,
    conflict_presence  = conflict_counts > 0
  )

```
actually working with the questions
```{r}
q37j_raw <- ab$Q37J

# Drop special missing codes
bad_codes <- c(8, 9, -1)
q37j_raw[q37j_raw %in% bad_codes] <- NA

# Now this is already 0–3
trust_trad_leaders <- q37j_raw

q37j_raw <- ab$Q37J
q37j_raw[q37j_raw %in% c(8, 9, -1)] <- NA
trust_trad_leaders <- make_trust_0_3(q37j_raw)

```
Mkaing an index
```{r}
#creating an index
trust_candidates <- c("Q37J", "Q37I", 'Q37F', 'Q37C', 'Q37B', 'Q37D', 'Q37K', 'Q37I')
trust_corrpution <- c("Q37J", "Q37I", 'Q37F', 'Q37C', 'Q37B', 'Q37D', 'Q37K', 'Q37I', "Q38D", "Q38E", "Q38F", "Q38G", "Q38H")
trust_cols <- trust_candidates[trust_candidates %in% names(ab_sf)]
if (length(trust_cols) == 0) {
  stop("Couldn't find any trust variables. Add their names to 'trust_candidates'.")
}

ab_sf <- ab_sf %>%
  mutate(
    across(
      all_of(trust_cols),
      make_trust_0_3,
      .names = "{.col}_0_3"
    )
  )
trust_corr <- trust_corrpution[trust_corrpution %in% names(ab_sf)]
if (length(trust_corr) == 0) {
  stop("Couldn't find any trust variables. Add their names to 'trust_candidates'.")
}
ab_sf <- ab_sf %>%
  mutate(
    across(
      all_of(trust_cols),
      make_trust_0_3,
      .names = "{.col}_0_3"
    )
  )

ab_sf <- ab_sf %>%
  mutate(
    across(
      all_of(trust_corr),
      make_trust_0_3,
      .names = "{.col}_0_3"
    )
  )

trust_index_cols <- paste0(trust_cols, "_0_3")
trust_index_cor <- paste0(trust_corr, "_0_3")
ab_sf <- ab_sf %>%
  rowwise() %>%
  mutate(
    trust_index = if_else(
      # require at least 2 non-missing items (you can change this)
      sum(!is.na(c_across(all_of(trust_index_cols)))) >= 2,
      mean(c_across(all_of(trust_index_cols)), na.rm = TRUE),
      NA_real_
    )
  ) %>%
  ungroup()
ab_sf <- ab_sf %>%
  rowwise() %>%
  mutate(
    trust_index = if_else(
      sum(!is.na(c_across(all_of(trust_index_cor)))) >= 2,
      mean(c_across(all_of(trust_index_cor)), na.rm = TRUE),
      NA_real_
    )
  ) %>%
  ungroup()

# Optional: controls if present (age/education/urban)
ctrls <- intersect(c("Q1", "Q2", "URBRUR", "Q100", "Q94", "Q95"), names(ab_sf))
# Country/region FEs if present
fe_country <- intersect(c("country", "country_name", "COUNTRY"), names(ab_sf))[1]
fe_region  <- intersect(c("region", "region_name", "ADM1NAME"), names(ab_sf))[1]


```

```{r}
density_var <- if ("pop_density" %in% names(ab_sf)) {
  "pop_density"
} else if ("pop_density_log" %in% names(ab_sf)) {
  "pop_density_log"
} else {
  stop("No population density variable found (pop_density or pop_density_log).")
}


# main regressors: trust + density + other controls
rhs_vars <- c("trust_index", density_var, ctrls)

# collapse into a single RHS string: e.g. "trust_index + pop_density + Q1 + Q2 + URBRUR + ..."
rhs_str <- paste(rhs_vars, collapse = " + ")

# Start with the basic part: DV ~ regressors
base_str <- paste0("conflict_presence ~ ", rhs_str)

# Build FE part depending on what exists
fe_part <- NULL

if (!is.na(fe_country) && !is.na(fe_region)) {
  fe_part <- paste(fe_country, fe_region, sep = " + ")
} else if (!is.na(fe_region)) {
  fe_part <- fe_region
} else if (!is.na(fe_country)) {
  fe_part <- fe_country
}

# Combine into final formula string
if (!is.null(fe_part)) {
  # fixest syntax: y ~ x1 + x2 | fe1 + fe2
  f_str <- paste(base_str, "|", fe_part)
} else {
  # no FEs available
  f_str <- base_str
}

f_logit <- as.formula(f_str)
f_logit



```

```{r}
library(fixest)

m_logit <- feglm(
  fml    = f_logit,
  data   = ab_sf,
  family = "binomial"
)

summary(m_logit)

```

# odds ratio
```{r}
library(broom)

coef_df <- tidy(m_logit) %>%
  filter(term != "(Intercept)") %>%
  mutate(
    or   = exp(estimate),              # odds ratio
    or_lo = exp(estimate - 1.96*std.error),
    or_hi = exp(estimate + 1.96*std.error)
  )

ggplot(coef_df, aes(x = term, y = or)) +
  geom_pointrange(aes(ymin = or_lo, ymax = or_hi)) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  coord_flip() +
  labs(
    x = NULL,
    y = "Odds ratio (logit model)",
    title = "Effect estimates from logit on conflict_presence"
  ) +
  theme_minimal()


```

```{r}
# 1) Get predicted probabilities from your logit
# ab_pred <- ab_sf %>%
#   st_drop_geometry() %>%                     # drop sf geometry
#   mutate(phat = predict(m_logit, type = "response"))  # model-implied prob of conflict
# 
# # 2) Average those probabilities by trust_index
# trust_curve <- ab_pred %>%
#   filter(!is.na(trust_index)) %>%
#   group_by(trust_index) %>%
#   summarise(
#     p_hat = mean(phat, na.rm = TRUE),
#     n     = n(),
#     # binomial SE for a mean proportion (simple, fine for plotting):
#     se    = sqrt(p_hat * (1 - p_hat) / n),
#     lower = p_hat - 1.96 * se,
#     upper = p_hat + 1.96 * se,
#     .groups = "drop"
  )
```

```{r}

# baseline RHS: density + other controls, no trust
rhs_base   <- c(density_var, ctrls)
rhs_base_s <- paste(rhs_base, collapse = " + ")
base_str   <- paste0("conflict_presence ~ ", rhs_base_s)

if (!is.null(fe_part)) {
  base_f_str <- paste(base_str, "|", fe_part)
} else {
  base_f_str <- base_str
}

f_base <- as.formula(base_f_str)

m_base <- feglm(
  fml    = f_base,
  data   = ab_sf,
  family = "binomial"
)

base_pr2 <- as.numeric(fitstat(m_base, "pr2"))


run_trust_model <- function(trust_var) {
  # RHS: this trust var + density + other controls
  rhs_vars <- c(trust_var, density_var, ctrls)
  rhs_str  <- paste(rhs_vars, collapse = " + ")
  
  base_str <- paste0("conflict_presence ~ ", rhs_str)
  
  # add FEs if we have them
  if (!is.null(fe_part)) {
    f_str <- paste(base_str, "|", fe_part)
  } else {
    f_str <- base_str
  }
  
  fml <- as.formula(f_str)
  
  m <- feglm(
    fml    = fml,
    data   = ab_sf,
    family = "binomial"
  )
  
  # coefficient + SE for THIS trust variable
  b  <- coef(m)[trust_var]
  se <- sqrt(vcov(m)[trust_var, trust_var])
  z  <- b / se
  p  <- 2 * pnorm(abs(z), lower.tail = FALSE)
  
  tibble(
    trust_var = trust_var,
    coef      = b,
    se        = se,
    z         = z,
    p         = p,
    or        = exp(b),
    aic       = as.numeric(fitstat(m, "aic")),
    bic       = as.numeric(fitstat(m, "bic")),
    pr2       = as.numeric(fitstat(m, "pr2")),
    d_pr2     = pr2 - base_pr2   # extra pseudo-R^2 beyond baseline model
  )
}

trust_results <- map_dfr(trust_predictors, run_trust_model)

# order by extra explanatory power
trust_results %>%
  arrange(desc(d_pr2))

library(ggplot2)

# nicer ordering: by extra pseudo-R^2
trust_results <- trust_results %>%
  mutate(trust_var = factor(trust_var, levels = trust_var[order(d_pr2)]))

trust_results_labeled <- trust_results %>%
  mutate(
    trust_label = dplyr::recode(
      trust_var,
      "Q37J_0_3"   = "Traditional Leaders",
      "Q37I_0_3"   = "Courts of Law",
      "Q37G_0_3"   = "Police",
      "Q37F_0_3"   = "Opposition Parties",
      "Q37C_0_3"   = "Electoral Commission",
      "trust_index" = "Trust index (all items)"
    )
  )

# Odds-ratio plot across questions
ggplot(trust_results_labeled, aes(x = trust_label, y = or)) +
  geom_pointrange(aes(
    ymin = exp(coef - 1.96 * se),
    ymax = exp(coef + 1.96 * se)
  )) +
  geom_hline(yintercept = 1, linetype = "dashed") +
  coord_flip() +
  labs(
    x = NULL,
    y = "Odds ratio for conflict presence\n(one-unit increase in trust)",
    title = "Trust question–by–question effects on conflict presence"
  ) +
  theme_minimal()


ggplot(trust_results, aes(x = trust_var, y = d_pr2)) +
  geom_col() +
  coord_flip() +
  labs(
    x = NULL,
    y = "Δ pseudo-R² vs. baseline (no trust)",
    title = "Which trust items add the most explanatory power?"
  ) +
  theme_minimal()
#shift share analysis

```
jdanfldhjfa;kdj